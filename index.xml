<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AllThingsEmbedded</title><link>https://allthingsembedded.com/staging-web/</link><description>Recent content on AllThingsEmbedded</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 02 Jan 2022 17:02:33 +0200</lastBuildDate><atom:link href="https://allthingsembedded.com/staging-web/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Structures: Ditto::static_ptr&lt;Base, Derived, ...></title><link>https://allthingsembedded.com/staging-web/post/data_structure_static_pointer/</link><pubDate>Sun, 02 Jan 2022 17:02:33 +0200</pubDate><guid>https://allthingsembedded.com/staging-web/post/data_structure_static_pointer/</guid><description>One of the nice things about C++ compared to C is its ability to define reusable types and data structures. They make code reuse easier and also help with reasoning if the abstraction is high-level enough.
Today we are going to talk about static_ptr from the library Ditto. Dynamic allocation is often forbidden when developing embedded systems. This leads to allocating most things either in the stack or globally. A static_ptr allows the user to statically allocate an object of a derived class and access it as a base class pointer.</description></item><item><title>Bare Metal C++ Register Access API</title><link>https://allthingsembedded.com/staging-web/post/bare-metal-register-access-api/</link><pubDate>Sat, 25 Sep 2021 20:26:21 +0200</pubDate><guid>https://allthingsembedded.com/staging-web/post/bare-metal-register-access-api/</guid><description>Introduction to memory-mapping Note: This section is introductory material for those who are not yet familiar with the concept of memory-mapping. If you are already experienced with memory-mapping feel free to jump to the next section. Most likely you won&amp;rsquo;t miss anything new.
One of the most common ways of accessing peripherals from a CPU is memory-mapping. In short, this means that the address space of the CPU has some addresses that when accessed read/write peripheral&amp;rsquo;s registers.</description></item><item><title>Mastering the GNU linker script</title><link>https://allthingsembedded.com/staging-web/post/2020-04-11-mastering-the-gnu-linker-script/</link><pubDate>Sat, 11 Apr 2020 21:25:34 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/post/2020-04-11-mastering-the-gnu-linker-script/</guid><description>Most people getting started with embedded development seem to find linker scripts just another piece of magic required to get up and running with their system. Even when they might already be familiar with memory-mapped peripherals and basic embedded concepts, the linker script and how it interacts with the GNU linker (ld) is still pretty mysterious.
Today we will go through the main functions of a linker script to try to shed some light onto their operation.</description></item><item><title>Bootloaders and ARM Cortex-M microcontrollers: Booting the target application</title><link>https://allthingsembedded.com/staging-web/post/2019-10-12-bootloaders-and-arm-cortex-m-microcontrollers-booting-the-target-application/</link><pubDate>Sat, 12 Oct 2019 18:23:57 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/post/2019-10-12-bootloaders-and-arm-cortex-m-microcontrollers-booting-the-target-application/</guid><description>In a previous blog we discussed the role of the NVIC in ARM Cortex-M microcontrollers. This peripheral will play a central role in booting our target application. First of all, we need to discuss the boot process in an ARM Cortex-M microcontroller.
Boot process After Power On Reset the microcontroller assumes the NVIC table is located at address 0x00000000. The processor fetches the first two words in the NVIC table, corresponding to the top of the stack and the reset vector.</description></item><item><title>Bootloaders and ARM Cortex-M microcontrollers: Design</title><link>https://allthingsembedded.com/staging-web/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/</link><pubDate>Fri, 31 May 2019 15:37:18 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/</guid><description>Welcome to the second entry of the Bootloader series! Today we are going to be discussing the design and basic architecture of the bootloader application.
As we talked about on the last post, we are not going to be using any libraries, other than the C++ standard library in order to maximize portability and performance and limit code bloat. This means that we will be writing our own Hardware Abstraction Layer for all the peripherals and core features of the bootloader.</description></item><item><title>Bootloaders and ARM Cortex-M microcontrollers (STM32F7): Introduction</title><link>https://allthingsembedded.com/staging-web/post/2019-05-19-bootloaders-and-arm-cortex-m-microcontrollers-stm32f7-introduction/</link><pubDate>Sun, 19 May 2019 17:23:30 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/post/2019-05-19-bootloaders-and-arm-cortex-m-microcontrollers-stm32f7-introduction/</guid><description>We are introducing a new series to the blog, containing all about bootloaders for small ARM Cortex-M microcontrollers. I hope you like it.
What is a bootloader? A bootloader is a piece of firmware that takes care of booting the target application, as well as providing a mechanism to update the firmware on the field, where you don&amp;rsquo;t have the means to flash the device using more advanced hardware interfaces such as JTAG, SWD or ICSP.</description></item><item><title>Getting SpiritDSP MP3 Decoder up and running on STM32 Microcontrollers</title><link>https://allthingsembedded.com/staging-web/post/2019-02-17-getting-spiritdsp-mp3-decoder-up-and-running-on-stm32-microcontrollers/</link><pubDate>Sun, 17 Feb 2019 14:44:58 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/post/2019-02-17-getting-spiritdsp-mp3-decoder-up-and-running-on-stm32-microcontrollers/</guid><description>After researching some alternatives for mp3 decoding on STM32 microcontrollers, I found ST&amp;rsquo;s X-CUBE-AUDIO, a set of libraries and components for audio processing. It turns out that SpiritDSP developed a version of their MP3 decoding libraries for STM microcontrollers.
You can download the software expansion kit following this link. It contains much more than just the SpiritDSP MP3 decoder, but this article will be focused just on how to get the MP3 decoder up and running.</description></item><item><title>ARM Cortex-M Startup code (for C and C++)</title><link>https://allthingsembedded.com/staging-web/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/</link><pubDate>Thu, 03 Jan 2019 09:00:50 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/</guid><description>When developing bare metal applications it is required to supply some functions that we normally take for granted when developing code for mainstream OS&amp;rsquo;s. Setting the startup code is not inherently difficult but beware: some of the nastiest bugs you will ever see on bare metal can come from the startup code.
What is actually needed to start the execution of the main function? Well, there are a few things that the C and C++ language specifications assume when starting a new program.</description></item><item><title>Cross-compiling for embedded devices</title><link>https://allthingsembedded.com/staging-web/2018/12/29/cross-compiling-for-embedded-devices/</link><pubDate>Sat, 29 Dec 2018 17:36:13 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/2018/12/29/cross-compiling-for-embedded-devices/</guid><description>Developing code for embedded devices is somewhat different from code for mainstream computers. One of these differences is the development environment.
Most of the target microcontrollers or microprocessors won&amp;rsquo;t usually be suited for local development. Imagine trying to build your code on the target when the target is a simple 8-bit Microcontroller. First of all you would need a compiler for the target architecture on the target device and it would probably be extra slow and inconvenient.</description></item><item><title>Adding GPT support to FatFS</title><link>https://allthingsembedded.com/staging-web/2018/12/29/adding-gpt-support-to-fatfs/</link><pubDate>Sat, 29 Dec 2018 11:27:30 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/2018/12/29/adding-gpt-support-to-fatfs/</guid><description>FatFs is an open source library used in many embedded devices to interface with FAT file systems in Block devices such as SD cards, flash drives, etc. It can load a FAT or ExFAT filesystem found inside a partition in an MBR partition table. However, it doesn&amp;rsquo;t provide support to find a FAT filesystem inside a GUID partition table.
This blog post will provide you with the knowledge required to load a FAT filesystem inside a GUID partition table using FatFS.</description></item><item><title>Displaying text on embedded devices</title><link>https://allthingsembedded.com/staging-web/2018/09/02/displaying-text-on-embedded-devices/</link><pubDate>Sun, 02 Sep 2018 04:00:37 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/2018/09/02/displaying-text-on-embedded-devices/</guid><description>There are many ways to display text on an embedded device, but not all of them may fit your HW design. This post will expose most of your options and give you a good intuition about what you need to know in order to create great graphics software. Even if you only do hardware, this will still be of interest to you, since you will get a better understanding of what the architecture of your system needs to be to be able to display text with a certain quality.</description></item><item><title>On controlling GPIO speed</title><link>https://allthingsembedded.com/staging-web/2018/06/23/on-controlling-gpio-speed/</link><pubDate>Sat, 23 Jun 2018 23:07:17 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/2018/06/23/on-controlling-gpio-speed/</guid><description>Most microcontrollers now include the options to select the GPIO speed for a certain pin inside a port. Many will announce this feature as GPIO max current control or slew-rate, but in the end they are talking about the same thing.
First of all, why would you ever need to control GPIO current? Wouldn&amp;rsquo;t it be great to leave this at the maximum level at all times? Well, it is usually not that simple, and more so as integrated circuits get larger clock frequencies.</description></item></channel></rss>