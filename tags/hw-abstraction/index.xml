<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HW Abstraction on AllThingsEmbedded</title><link>https://allthingsembedded.com/staging-web/tags/hw-abstraction/</link><description>Recent content in HW Abstraction on AllThingsEmbedded</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 31 May 2019 15:37:18 +0000</lastBuildDate><atom:link href="https://allthingsembedded.com/staging-web/tags/hw-abstraction/index.xml" rel="self" type="application/rss+xml"/><item><title>Bootloaders and ARM Cortex-M microcontrollers: Design</title><link>https://allthingsembedded.com/staging-web/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/</link><pubDate>Fri, 31 May 2019 15:37:18 +0000</pubDate><guid>https://allthingsembedded.com/staging-web/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/</guid><description>Welcome to the second entry of the Bootloader series! Today we are going to be discussing the design and basic architecture of the bootloader application.
As we talked about on the last post, we are not going to be using any libraries, other than the C++ standard library in order to maximize portability and performance and limit code bloat. This means that we will be writing our own Hardware Abstraction Layer for all the peripherals and core features of the bootloader.</description></item></channel></rss>