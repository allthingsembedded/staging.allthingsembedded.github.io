<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Firmware on AllThingsEmbedded</title><link>https://allthingsembedded.com/tags/firmware/</link><description>Recent content in Firmware on AllThingsEmbedded</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 31 May 2019 15:37:18 +0000</lastBuildDate><atom:link href="https://allthingsembedded.com/tags/firmware/index.xml" rel="self" type="application/rss+xml"/><item><title>Bootloaders and ARM Cortex-M microcontrollers: Design</title><link>https://allthingsembedded.com/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/</link><pubDate>Fri, 31 May 2019 15:37:18 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/</guid><description>Welcome to the second entry of the Bootloader series! Today we are going to be discussing the design and basic architecture of the bootloader application.
As we talked about on the last post, we are not going to be using any libraries, other than the C++ standard library in order to maximize portability and performance and limit code bloat. This means that we will be writing our own Hardware Abstraction Layer for all the peripherals and core features of the bootloader.</description></item><item><title>Bootloaders and ARM Cortex-M microcontrollers (STM32F7): Introduction</title><link>https://allthingsembedded.com/post/2019-05-19-bootloaders-and-arm-cortex-m-microcontrollers-stm32f7-introduction/</link><pubDate>Sun, 19 May 2019 17:23:30 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-05-19-bootloaders-and-arm-cortex-m-microcontrollers-stm32f7-introduction/</guid><description>We are introducing a new series to the blog, containing all about bootloaders for small ARM Cortex-M microcontrollers. I hope you like it.
What is a bootloader? A bootloader is a piece of firmware that takes care of booting the target application, as well as providing a mechanism to update the firmware on the field, where you don&amp;rsquo;t have the means to flash the device using more advanced hardware interfaces such as JTAG, SWD or ICSP.</description></item><item><title>ARM Cortex-M Startup code (for C and C++)</title><link>https://allthingsembedded.com/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/</link><pubDate>Thu, 03 Jan 2019 09:00:50 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/</guid><description>When developing bare metal applications it is required to supply some functions that we normally take for granted when developing code for mainstream OS&amp;rsquo;s. Setting the startup code is not inherently difficult but beware: some of the nastiest bugs you will ever see on bare metal can come from the startup code.
What is actually needed to start the execution of the main function? Well, there are a few things that the C and C++ language specifications assume when starting a new program.</description></item></channel></rss>