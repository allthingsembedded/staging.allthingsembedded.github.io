<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Bootloaders and ARM Cortex-M microcontrollers: Booting the target application - AllThingsEmbedded</title>
<meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Javier Alvarez"><meta name=description content="In a previous blog we discussed the role of the NVIC in ARM Cortex-M microcontrollers. This peripheral will play a central role in booting our target application. First of all, we need to discuss the boot process in an ARM Cortex-M microcontroller.
Boot process After Power On Reset the microcontroller assumes the NVIC table is located at address 0x00000000. The processor fetches the first two words in the NVIC table, corresponding to the top of the stack and the reset vector."><meta name=keywords content="Software,Embedded,Engineering"><meta name=generator content="Hugo 0.124.1 with theme even"><link rel=canonical href=https://allthingsembedded.com/staging-web/post/2019-10-12-bootloaders-and-arm-cortex-m-microcontrollers-booting-the-target-application/><link rel=apple-touch-icon sizes=180x180 href=/staging-web/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/staging-web/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/staging-web/favicon-16x16.png><link rel=manifest href=/staging-web/manifest.json><link rel=mask-icon href=/staging-web/safari-pinned-tab.svg color=#5bbad5><link href=/staging-web/sass/main.min.64709dea827fd8cd68163871eecb608b9747dba02f31ef7b78b54b5be491b06c.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Bootloaders and ARM Cortex-M microcontrollers: Booting the target application"><meta property="og:description" content="In a previous blog we discussed the role of the NVIC in ARM Cortex-M microcontrollers. This peripheral will play a central role in booting our target application. First of all, we need to discuss the boot process in an ARM Cortex-M microcontroller.
Boot process After Power On Reset the microcontroller assumes the NVIC table is located at address 0x00000000. The processor fetches the first two words in the NVIC table, corresponding to the top of the stack and the reset vector."><meta property="og:type" content="article"><meta property="og:url" content="https://allthingsembedded.com/staging-web/post/2019-10-12-bootloaders-and-arm-cortex-m-microcontrollers-booting-the-target-application/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-10-12T18:23:57+00:00"><meta property="article:modified_time" content="2019-10-12T18:23:57+00:00"><meta itemprop=name content="Bootloaders and ARM Cortex-M microcontrollers: Booting the target application"><meta itemprop=description content="In a previous blog we discussed the role of the NVIC in ARM Cortex-M microcontrollers. This peripheral will play a central role in booting our target application. First of all, we need to discuss the boot process in an ARM Cortex-M microcontroller.
Boot process After Power On Reset the microcontroller assumes the NVIC table is located at address 0x00000000. The processor fetches the first two words in the NVIC table, corresponding to the top of the stack and the reset vector."><meta itemprop=datePublished content="2019-10-12T18:23:57+00:00"><meta itemprop=dateModified content="2019-10-12T18:23:57+00:00"><meta itemprop=wordCount content="1085"><meta itemprop=keywords content="ARM,bootloader,Cortex-M,STM32F7,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bootloaders and ARM Cortex-M microcontrollers: Booting the target application"><meta name=twitter:description content="In a previous blog we discussed the role of the NVIC in ARM Cortex-M microcontrollers. This peripheral will play a central role in booting our target application. First of all, we need to discuss the boot process in an ARM Cortex-M microcontroller.
Boot process After Power On Reset the microcontroller assumes the NVIC table is located at address 0x00000000. The processor fetches the first two words in the NVIC table, corresponding to the top of the stack and the reset vector."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo id=mobile-header-logo></a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/staging-web/><li class=mobile-menu-item>Home</li></a><a href=/staging-web/post/><li class=mobile-menu-item>Archives</li></a><a href=/staging-web/tags/><li class=mobile-menu-item>Tags</li></a></ul></nav><script type=text/javascript src=/js/common.js></script><script type=text/javascript>colorize_base16("mobile-header-logo","AllThingsEmbedded")</script><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo id=logo-wrapper></a></div><script type=text/javascript src=/js/common.js></script><script type=text/javascript>colorize_base16("logo-wrapper","AllThingsEmbedded")</script><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/staging-web/>Home</a></li><li class=menu-item><a class=menu-item-link href=/staging-web/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/staging-web/tags/>Tags</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Bootloaders and ARM Cortex-M microcontrollers: Booting the target application</h1><div class=post-meta><span class=post-time>2019-10-12</span><div class=post-category><a href=/staging-web/categories/bootloader/>Bootloader</a></div><span class=more-meta>1085 words </span><span class=more-meta>6 mins read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#boot-process>Boot process</a></li><li><a href=#booting-the-target-application>Booting the target application</a></li><li><a href=#a-note-about-the-top-of-the-stack>A note about the top of the stack</a></li><li><a href=#tips-for-writing-the-target-application>Tips for writing the target application</a></li></ul></li></ul></nav></div></div><div class=post-content><p>In a previous <a href=/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/>blog</a> we discussed the role of the NVIC in ARM Cortex-M microcontrollers. This peripheral will play a central role in booting our target application. First of all, we need to discuss the boot process in an ARM Cortex-M microcontroller.</p><h2 id=boot-process>Boot process</h2><ul><li>After Power On Reset the microcontroller assumes the NVIC table is located at address 0x00000000.</li><li>The processor fetches the first two words in the NVIC table, corresponding to the <strong>top of the stack</strong> and the <strong>reset vector</strong>.</li><li>It sets the MSP (Main stack pointer) to the top of the stack.</li><li>It jumps to the address indicated by the reset vector.</li><li>Application program execution begins.</li></ul><p>In the case of our bootloader, the processor will be loading the top of the stack and the reset vector of our bootloader and then start executing it. Then, we the bootloader decides if it can boot an application already present at flash memory or if it needs to load an application using the loader. No matter which is chosen, it will eventually have to boot the target application.</p><p>Looking at the regular reset process we can see that there is a big assumption the processor makes. It assumes that the NVIC table is located at address <code>0x00000000</code>. This is why many vendors actually provide <strong>boot pins</strong> to alias the first section of memory to other memory sections or devices. This is used also for embedding vendor-provided bootloaders into an OTP memory and such. For example, an STM32F7 processor uses the following boot pin configuration:</p><p><img src=/images/stm32f7_boot_mode_selection.png alt="Boot mode selection for STM32F7"></p><p>Some microcontrollers will even provide you with methods to override these boot addresses, but we will assume that is not an option for us (to make our bootloader more generic).</p><p>So in order to boot the target application we have to replicate the boot process the processor does at the hardware level.</p><h2 id=booting-the-target-application>Booting the target application</h2><p>Now that we know the requirements to boot the target application, we have all the tools we need to develop our own boot code. The easiest way is to:</p><ul><li>Obtain the <strong>NVIC relocation offset</strong> for the target application. This information is dependent on the target application itself, but we can simply provide this information to the bootloader when we load the ELF file through a bootloader application for a host computer. We will use the convention that the NVIC table is located in an ELF section called <code>.isr_vector</code>.</li><li>Set the NVIC relocation offset so that after booting the target application all interrupts and exceptions will actually call the target application code. This is done via the <code>VTOR</code> (Vector table offset register).</li><li>Before setting the NVIC relocation offset though, <strong>we have to make sure that we disabled all peripherals and interrupts</strong>. <strong>Otherwise</strong>, if we are using the UART1 and the target application doesn&rsquo;t <strong>we risk entering the default ISR handler</strong> of the target application. This handler is typically an infinite loop.</li><li>Now we are 100% ready to boot the target application. We simply <strong>set the MSP to the first word of the target NVIC table.</strong></li><li>Then we <strong>jump to the Reset vector of the target application</strong> code (which we know is the second word in the target application NVIC table).</li></ul><p>This is what we do in the following lines of code:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>App</span><span class=o>::</span><span class=n>Bootloader</span><span class=o>::</span><span class=n>boot</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>uintptr_t</span> <span class=n>addr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>disablePeripherals</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Hw</span><span class=o>::</span><span class=n>uCSystemControlBlock</span><span class=o>::</span><span class=n>relocateVectorTable</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Set Stack pointer and jump to target
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>asm</span><span class=p>(</span><span class=s>&#34;ldr sp, =_estack</span><span class=se>\r\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;ldr pc, &amp;#91;%0, #4]</span><span class=se>\r\n</span><span class=s>&#34;</span> <span class=o>:</span> <span class=o>:</span> <span class=s>&#34;r&#34;</span> <span class=p>(</span><span class=n>addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The boot method is receiving the address at which the NVIC table is located. It disables all peripherals and relocates the NVIC table. Finally, it loads into the SP register (which in our application is the MSP since we don&rsquo;t use the PSP) and then loads the program counter (PC) with the address located at the second word of the target application NVIC table.</p><p>There is a good reason why the last two instructions are written in assembly. In C/C++ there is no way for us to access the stack pointer and write it as a register. The same goes for the program counter. You could, in theory, declare a function pointer to a function that doesn&rsquo;t take any arguments and doesn&rsquo;t return anything and make it point to the reset vector and then call the function. Since the function doesn&rsquo;t take any arguments it should not mess with the stack pointer. However, it is more explicit and less confusing to do this small bit in assembler.</p><h2 id=a-note-about-the-top-of-the-stack>A note about the top of the stack</h2><p>Notice how in the code I didn&rsquo;t actually use the target application NVIC table to obtain the top of the stack. Instead, I am using <code>__estack_</code>, a constant defined by the linker at compile time (as given by my linker script config).</p><p>The reason for doing this is simply that there is no need to lookup this value in the target application. The top of the stack doesn&rsquo;t change (or shouldn&rsquo;t) between the bootloader and the application, so we might as well use the bootloader value.</p><p>However, there might be some cases where you&rsquo;d want to customize this for the target application. Think about reserving memory outside the C/C++ memory layout for another use. Since this isn&rsquo;t a common usecase, I decided to ignore it and go with the value from the bootloader.</p><h2 id=tips-for-writing-the-target-application>Tips for writing the target application</h2><p>It&rsquo;s important to remember that our target application will not be located in the common memory addresses that our IDE or example code might supply us with. This means that we need to make sure that the region of memory reserved for the bootloader is not written and will not be written in runtime.</p><p>So, in the <strong>linker script</strong> for the target application we must declare the Flash memory starting from the second block of Flash memory instead of the first.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>MEMORY</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=n>ITCMFLASH</span> <span class=p>(</span><span class=n>rx</span><span class=p>)</span>   <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x00208000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>992</span><span class=n>K</span>
</span></span><span class=line><span class=cl><span class=n>FLASH</span> <span class=p>(</span><span class=n>rx</span><span class=p>)</span>      <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x08008000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>992</span><span class=n>K</span>
</span></span><span class=line><span class=cl><span class=n>RAM</span> <span class=p>(</span><span class=n>xrw</span><span class=p>)</span>      <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x20000000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>320</span><span class=n>K</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Another important detail is that <strong>many vendors use the startup code to set the the NVIC Table Offset</strong> to the start of the Flash or the start of RAM (depending on the configuration for the project). If you see that after booting the application an ISR located in the bootloader is getting called, that&rsquo;s most likely the reason. <strong>You need to make sure that the VTOR register is not modified after boot.</strong> Otherwise, your application will not behave as intended.</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Javier Alvarez</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2019-10-12</span></p></div><footer class=post-footer><div class=post-tags><a href=/staging-web/tags/arm/>ARM</a>
<a href=/staging-web/tags/bootloader/>bootloader</a>
<a href=/staging-web/tags/cortex-m/>Cortex-M</a>
<a href=/staging-web/tags/stm32f7/>STM32F7</a></div><nav class=post-nav><a class=prev href=/staging-web/post/2020-04-11-mastering-the-gnu-linker-script/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Mastering the GNU linker script</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/staging-web/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/><span class="next-text nav-default">Bootloaders and ARM Cortex-M microcontrollers: Design</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=allthingsembedded/allthingsembedded.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:javier.alvarez@allthingsembedded.net class="iconfont icon-email" title=email></a><a href=https://twitter.com/Javier_varez class="iconfont icon-twitter" title=twitter></a><a href="https://www.linkedin.com/in/javieralvarez17/?locale=en_US" class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/Javier-varez class="iconfont icon-github" title=github></a><a href type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span><span class=copyright-year>&copy;
2018 -
2024<span class=heart><i class="iconfont icon-heart"></i></span><span></span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/staging-web/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script><script type=text/javascript>window.MathJax={tex:{}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>