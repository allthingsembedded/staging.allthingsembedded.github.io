<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Mastering the GNU linker script - AllThingsEmbedded</title>
<meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Javier Alvarez"><meta name=description content="Most people getting started with embedded development seem to find linker scripts just another piece of magic required to get up and running with their system. Even when they might already be familiar with memory-mapped peripherals and basic embedded concepts, the linker script and how it interacts with the GNU linker (ld) is still pretty mysterious.
Today we will go through the main functions of a linker script to try to shed some light onto their operation."><meta name=keywords content="Software,Embedded,Engineering"><meta name=generator content="Hugo 0.124.1 with theme even"><link rel=canonical href=https://allthingsembedded.com/staging-web/post/2020-04-11-mastering-the-gnu-linker-script/><link rel=apple-touch-icon sizes=180x180 href=/staging-web/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/staging-web/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/staging-web/favicon-16x16.png><link rel=manifest href=/staging-web/manifest.json><link rel=mask-icon href=/staging-web/safari-pinned-tab.svg color=#5bbad5><link href=/staging-web/sass/main.min.64709dea827fd8cd68163871eecb608b9747dba02f31ef7b78b54b5be491b06c.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Mastering the GNU linker script"><meta property="og:description" content="Most people getting started with embedded development seem to find linker scripts just another piece of magic required to get up and running with their system. Even when they might already be familiar with memory-mapped peripherals and basic embedded concepts, the linker script and how it interacts with the GNU linker (ld) is still pretty mysterious.
Today we will go through the main functions of a linker script to try to shed some light onto their operation."><meta property="og:type" content="article"><meta property="og:url" content="https://allthingsembedded.com/staging-web/post/2020-04-11-mastering-the-gnu-linker-script/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-04-11T21:25:34+00:00"><meta property="article:modified_time" content="2020-04-11T21:25:34+00:00"><meta itemprop=name content="Mastering the GNU linker script"><meta itemprop=description content="Most people getting started with embedded development seem to find linker scripts just another piece of magic required to get up and running with their system. Even when they might already be familiar with memory-mapped peripherals and basic embedded concepts, the linker script and how it interacts with the GNU linker (ld) is still pretty mysterious.
Today we will go through the main functions of a linker script to try to shed some light onto their operation."><meta itemprop=datePublished content="2020-04-11T21:25:34+00:00"><meta itemprop=dateModified content="2020-04-11T21:25:34+00:00"><meta itemprop=wordCount content="2764"><meta itemprop=keywords content="ARM,Binutils,Cortex-M,GNU,Linker Script,Microcontroller,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mastering the GNU linker script"><meta name=twitter:description content="Most people getting started with embedded development seem to find linker scripts just another piece of magic required to get up and running with their system. Even when they might already be familiar with memory-mapped peripherals and basic embedded concepts, the linker script and how it interacts with the GNU linker (ld) is still pretty mysterious.
Today we will go through the main functions of a linker script to try to shed some light onto their operation."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo id=mobile-header-logo></a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/staging-web/><li class=mobile-menu-item>Home</li></a><a href=/staging-web/post/><li class=mobile-menu-item>Archives</li></a><a href=/staging-web/tags/><li class=mobile-menu-item>Tags</li></a></ul></nav><script type=text/javascript src=/js/common.js></script><script type=text/javascript>colorize_base16("mobile-header-logo","AllThingsEmbedded")</script><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo id=logo-wrapper></a></div><script type=text/javascript src=/js/common.js></script><script type=text/javascript>colorize_base16("logo-wrapper","AllThingsEmbedded")</script><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/staging-web/>Home</a></li><li class=menu-item><a class=menu-item-link href=/staging-web/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/staging-web/tags/>Tags</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Mastering the GNU linker script</h1><div class=post-meta><span class=post-time>2020-04-11 </span><span class=more-meta>2764 words </span><span class=more-meta>13 mins read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#object-files-and-symbols>Object files and symbols</a></li><li><a href=#sections>Sections</a></li><li><a href=#the-role-of-the-linker-in-detail>The role of the linker in detail</a></li><li><a href=#controlling-the-placement-of-output-sections>Controlling the placement of output sections</a></li><li><a href=#implicit-placement-of-output-sections>Implicit placement of output sections</a></li><li><a href=#placement-of-output-sections-using-explicit-addresses>Placement of output sections using explicit addresses</a></li><li><a href=#placement-of-output-sections-using-regions>Placement of output sections using regions</a></li><li><a href=#specifying-symbols-in-the-linker-script>Specifying symbols in the linker script</a></li><li><a href=#some-final-thoughts>Some final thoughts</a></li></ul></li></ul></nav></div></div><div class=post-content><p>Most people getting started with embedded development seem to find linker scripts just another piece of magic required to get up and running with their system. Even when they might already be familiar with memory-mapped peripherals and basic embedded concepts, the linker script and how it interacts with the GNU linker (ld) is still pretty mysterious.</p><p>Today we will go through the main functions of a linker script to try to shed some light onto their operation. We covered the basic of cross compilation in a previous post. We mentioned that the linker would be the last step in the compilation process. The job of the linker is to take all input object files and libraries (both shared and static) and generate a single executable file. Let&rsquo;s start with some terminology.</p><h2 id=object-files-and-symbols>Object files and symbols</h2><p>Object files are the generated output produced by the assembly. They contain the machine code as translated by the assembler. As part of an object file, they also contain references to symbols used in the code. These references may be defined in the object file itself (think of a local variable in the source of the object file) or undefined (like a function from a standard library, that is not provided by your object file). Symbols refer to both code and data and they serve to identify where a function starts and where a variable is located in an object file.</p><h2 id=sections>Sections</h2><p>Object files usually contain multiple sections. Each section contains either code or data that is needed for the target application. Usually the following sections are common in a C program:</p><ul><li><code>.text</code>: This section contains the code. This is, the machine language instructions that will be executed by the processor. In here we will find symbols that reference the functions in your object file.</li><li><code>.rodata</code>: This contains any data that is marked as read only. It is not unusual to find this data interleaved with the text section.</li><li><code>.data</code>: This section contains initialized global and static variables. Any global object that has been explicitly initialized to a value different than zero.</li><li><code>.bss</code>: Contains all uninitialized global and static variables. These are usually zeroed out by the startup code before we reach the main function. However, In an embedded system we usually provide our own startup code, which means we need to remember to do this ourselves. I wrote a nice article about the startup code a while back <a href=/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/>here</a>.</li><li><code>.isr_vector</code>: Contains the addresses of every Interrupt Service Routine. This is architecture specific and therefore not common to every microcontroller. It is, however, required for <a href=https://developer.arm.com/docs/dui0552/latest/the-cortex-m3-processor/exception-model/vector-table>Cortex-M microcontrollers</a>.</li></ul><h2 id=the-role-of-the-linker-in-detail>The role of the linker in detail</h2><p>The job of the linker is to take all object files and libraries to be linked and create an executable. In order to do this, it must take all symbols from the object files, resolve unknown symbols on each input object file (this is, finding out which object file provides each missing symbol) and create a single output file with no unresolved symbols (except of those of dynamically linked libraries, which are resolved during runtime).</p><p>Multiple input sections in object files map to different output sections in the output file of the linker. The linker script takes care of specifying the memory layout of each output section. We define all output sections inside the SECTION command:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/* Define output sections */</span>
</span></span><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nl>isr_vector</span> <span class=p>:</span> <span class=p>{</span> <span class=cm>/* This is the output section .isr_vector */</span>
</span></span><span class=line><span class=cl>    <span class=n>exceptions</span><span class=p>.</span><span class=n>o</span> <span class=p>(.</span><span class=n>isr_vector</span><span class=p>)</span> <span class=cm>/* This matches all .isr_vector sections in the exceptions.o input file */</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nl>text</span> <span class=p>:</span> <span class=p>{</span> <span class=cm>/* This is the output section .text */</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span> <span class=cm>/* This matches all .text sections in all input files */</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=o>*</span><span class=p>)</span> <span class=cm>/* This matches all .text* sections in all input files */</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The above <code>SECTIONS</code> command specifies two output sections in our output file. The <code>.isr_vector</code> output section will contain the input section <code>.isr_vector</code> of the exceptions.o input file. This can be used, for example, to place a vector table at a specific position in memory. In this case, this would be placed before the <code>.text</code> section in our output file.</p><p>In contrast, the <code>.text</code> output section will contain all <code>.text</code> sections in all input files. Notice the use of the wildcard to match any input files. Notice that two lines are present inside the <code>.text</code> output section. It is possible to take multiple input sections and merge them into a single output section. In fact, the second line in the <code>.text</code> output section <code>*(.text*)</code> matches all sections that begin with <code>.text</code> into the output section <code>.text</code>, meaning that if we had an input section named <code>.text.mysection</code> it would also be matched. This second line is specially useful when used in conjunction with the gcc option <code>-ffunction-sections</code>. Let&rsquo;s see an example of this in the following code snippet:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// test.c file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>MyFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>MySecondFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something here too
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>If we compile this code into an object file without using <code>-ffunction-sections</code> we should expect to see only one .text section containing the both symbols <code>MyFunction</code> and <code>MySecondFunctions</code>. We can build the object file with <code>gcc -c -o test.o test.c</code> . Now we check the symbols with <code>objdump -S test.o</code> and obtain:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>test</span><span class=p>.</span><span class=nl>o</span><span class=p>:</span>     <span class=n>file</span> <span class=n>format</span> <span class=n>elf64</span><span class=o>-</span><span class=n>x86</span><span class=o>-</span><span class=mi>64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Disassembly</span> <span class=n>of</span> <span class=n>section</span> <span class=p>.</span><span class=nl>text</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mo>0000000000000000</span> <span class=o>&lt;</span><span class=n>MyFunction</span><span class=o>&gt;:</span>
</span></span><span class=line><span class=cl>   <span class=mi>0</span><span class=o>:</span>   <span class=mi>55</span>                      <span class=n>push</span>   <span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mi>1</span><span class=o>:</span>   <span class=mi>48</span> <span class=mi>89</span> <span class=n>e5</span>                <span class=n>mov</span>    <span class=o>%</span><span class=n>rsp</span><span class=p>,</span><span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mi>4</span><span class=o>:</span>   <span class=mi>90</span>                      <span class=n>nop</span>
</span></span><span class=line><span class=cl>   <span class=mi>5</span><span class=o>:</span>   <span class=mi>5</span><span class=n>d</span>                      <span class=n>pop</span>    <span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mi>6</span><span class=o>:</span>   <span class=n>c3</span>                      <span class=n>retq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mo>0000000000000007</span> <span class=o>&lt;</span><span class=n>MySecondFunction</span><span class=o>&gt;:</span>
</span></span><span class=line><span class=cl>   <span class=mi>7</span><span class=o>:</span>   <span class=mi>55</span>                      <span class=n>push</span>   <span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mi>8</span><span class=o>:</span>   <span class=mi>48</span> <span class=mi>89</span> <span class=n>e5</span>                <span class=n>mov</span>    <span class=o>%</span><span class=n>rsp</span><span class=p>,</span><span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=nl>b</span><span class=p>:</span>   <span class=n>b8</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span>          <span class=n>mov</span>    <span class=err>$</span><span class=mh>0x0</span><span class=p>,</span><span class=o>%</span><span class=n>eax</span>
</span></span><span class=line><span class=cl>  <span class=mi>10</span><span class=o>:</span>   <span class=mi>5</span><span class=n>d</span>                      <span class=n>pop</span>    <span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>  <span class=mi>11</span><span class=o>:</span>   <span class=n>c3</span>                      <span class=n>retq</span>
</span></span></code></pre></td></tr></table></div></div><p>However, if we build with <code>gcc -c -o test.o test.c -ffunction-sections</code> we will see the following output:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>test</span><span class=p>.</span><span class=nl>o</span><span class=p>:</span>     <span class=n>file</span> <span class=n>format</span> <span class=n>elf64</span><span class=o>-</span><span class=n>x86</span><span class=o>-</span><span class=mi>64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Disassembly</span> <span class=n>of</span> <span class=n>section</span> <span class=p>.</span><span class=n>text</span><span class=p>.</span><span class=nl>MyFunction</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mo>0000000000000000</span> <span class=o>&lt;</span><span class=n>MyFunction</span><span class=o>&gt;:</span>
</span></span><span class=line><span class=cl>   <span class=mi>0</span><span class=o>:</span>   <span class=mi>55</span>                      <span class=n>push</span>   <span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mi>1</span><span class=o>:</span>   <span class=mi>48</span> <span class=mi>89</span> <span class=n>e5</span>                <span class=n>mov</span>    <span class=o>%</span><span class=n>rsp</span><span class=p>,</span><span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mi>4</span><span class=o>:</span>   <span class=mi>90</span>                      <span class=n>nop</span>
</span></span><span class=line><span class=cl>   <span class=mi>5</span><span class=o>:</span>   <span class=mi>5</span><span class=n>d</span>                      <span class=n>pop</span>    <span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mi>6</span><span class=o>:</span>   <span class=n>c3</span>                      <span class=n>retq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Disassembly</span> <span class=n>of</span> <span class=n>section</span> <span class=p>.</span><span class=n>text</span><span class=p>.</span><span class=nl>MySecondFunction</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mo>0000000000000000</span> <span class=o>&lt;</span><span class=n>MySecondFunction</span><span class=o>&gt;:</span>
</span></span><span class=line><span class=cl>   <span class=mi>0</span><span class=o>:</span>   <span class=mi>55</span>                      <span class=n>push</span>   <span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mi>1</span><span class=o>:</span>   <span class=mi>48</span> <span class=mi>89</span> <span class=n>e5</span>                <span class=n>mov</span>    <span class=o>%</span><span class=n>rsp</span><span class=p>,</span><span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mi>4</span><span class=o>:</span>   <span class=n>b8</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span>          <span class=n>mov</span>    <span class=err>$</span><span class=mh>0x0</span><span class=p>,</span><span class=o>%</span><span class=n>eax</span>
</span></span><span class=line><span class=cl>   <span class=mi>9</span><span class=o>:</span>   <span class=mi>5</span><span class=n>d</span>                      <span class=n>pop</span>    <span class=o>%</span><span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=nl>a</span><span class=p>:</span>   <span class=n>c3</span>                      <span class=n>retq</span>
</span></span></code></pre></td></tr></table></div></div><p>Now each function has it&rsquo;s own section. This is useful if we want to control exact placement of some functions in the output file, as we can now specify the section of the function we want to place. It is also useful when used in conjunction with the<code>--gc-sections</code> option of the GNU linker, which will remove any unused input sections from the output file, thus optimizing the size of the target binary.</p><p>We must, however, be careful about <code>--gc-sections</code>. Some microcontrollers (like the architecture ARMv6m and ARMv7m) require the presence of a table containing the reset and exception vector in some pre-established memory location. This table may be written as a C array and it is usually not referenced by the code itself. This means that it will be an unused symbol and the linker may remove it if we specify <code>--gc-sections</code>. It is possible to tell the linker to not remove a specific input section by wrapping it with the command <code>KEEP</code>. Here is an example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>KEEP</span><span class=p>(</span><span class=n>exceptions</span><span class=p>.</span><span class=n>o</span> <span class=p>(.</span><span class=n>isr_vector</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>As well as <code>-ffunction-sections</code> separates functions into sections, there is also <code>-fdata-sections</code>, which will place each data symbol in multiple sections.</p><h2 id=controlling-the-placement-of-output-sections>Controlling the placement of output sections</h2><p>So far we have seen how to control output sections and what they will contain mapping input sections to them. However, we had no control on where they will be placed on memory. There are a few ways we can specify this. Let&rsquo;s start by defining two types of addresses where symbols can be placed:</p><ul><li><strong>LMA</strong> or Load Memory Address. Specifies where the section and associated data shall be loaded into memory.</li><li><strong>VMA</strong> or Virtual Memory Address. Specifies the virtual address for the section, which will be used during runtime by the program to access the symbols in it.</li></ul><p>Normally, these two addresses are the same, but there are a few cases where they may differ. Think about the case of the output .data section. We need to load this somewhere in persistent memory in our microcontroller, but during runtime, we shall access this section from random access memory. The job of the startup code is to copy the data from the LMA to the VMA to make sure it will be accessible from our program in RAM.</p><h2 id=implicit-placement-of-output-sections>Implicit placement of output sections</h2><p>The linker script keeps an internal variable <code>.</code> called the <strong>location counter</strong>. This will hold the current memory address. It starts with a value of zero at the top of the file. As we add new sections, it will increment by the size of each section. If we simply don&rsquo;t specify any addresses at all, the placement of each section will be implicitly given by the value of the location counter when the linker gets to that section. In the example above, section <code>.isr_vector</code> will be placed at address 0, as we didn&rsquo;t set the location counter before defining it. If we assume that the isr vector takes 1023 bytes, then the <code>.text</code> output section will be placed at address 1023, as it is the value of the location counter when the .text section is defined.</p><p>Many architectures require code to be aligned to a certain number of bytes. In the case of ARM, it should be aligned to 2 bytes at least. We could ensure alignment of the text section to 4 bytes by explicitly modifying the location counter with the ALIGN function. The align function will introduce the required padding in order to align the location counter.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nl>isr_vector</span> <span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exceptions</span><span class=p>.</span><span class=n>o</span> <span class=p>(.</span><span class=n>isr_vector</span><span class=p>)</span> <span class=cm>/* We assume this takes 1023 bytes */</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nl>text</span> <span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=o>=</span> <span class=n>ALIGN</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The previous example shows how to align properly the .text output section. It is also possible to explicitly set a value of the location counter before the start of the output section. Let&rsquo;s say we want to place the isr vector at address 0x08000000 and the code at 0x08000400. We could write the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span> <span class=o>=</span> <span class=mh>0x08000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nl>isr_vector</span> <span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exceptions</span><span class=p>.</span><span class=n>o</span> <span class=p>(.</span><span class=n>isr_vector</span><span class=p>)</span> <span class=cm>/* We assume this takes 1023 bytes */</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>.</span> <span class=o>=</span> <span class=mh>0x08000400</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nl>text</span> <span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=o>=</span> <span class=n>ALIGN</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>These examples, however, set both the LMA and VMA to the same address and therefore cannot be relocated during runtime.</p><h2 id=placement-of-output-sections-using-explicit-addresses>Placement of output sections using explicit addresses</h2><p>In order to specify the VMA of an output section, we can simply use the address where we wish to place the output section, like the following example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=p>.</span><span class=n>isr_vector</span> <span class=mh>0x08000000</span> <span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>exceptions</span><span class=p>.</span><span class=n>o</span> <span class=p>(.</span><span class=n>isr_vector</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>In the previous example, we place the output section <code>.isr_vector</code> at address <code>0x08000000</code>. This will set both the VMA and LMA. If we wish to load a section somewhere else in memory we could do the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=p>.</span><span class=n>data</span> <span class=mh>0x20000000</span> <span class=o>:</span> <span class=n>AT</span><span class=p>(</span><span class=mh>0x08004000</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This will assign output section <code>.data</code> with VMA <code>0x20000000</code> and LMA <code>0x08004000</code>. The AT function is required by the syntax of the linker. It simply indicates the linker that the address is the LMA instead of the VMA. In short, this linker script snippet will load the section into memory at address 0x08004000, but the code will access this section during runtime at address 0x20000000.</p><h2 id=placement-of-output-sections-using-regions>Placement of output sections using regions</h2><p>The last and preferred option for placing output sections is to use regions. Instead of directly assigning a specific set of addresses to the target section we could define an array of memory regions that details the available memories in our system. An example is provided in the following snippet.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>MEMORY</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>FLASH</span> <span class=p>(</span><span class=n>rx</span><span class=p>)</span>      <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x08000000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>1024</span><span class=n>K</span>
</span></span><span class=line><span class=cl>  <span class=n>SRAM</span> <span class=p>(</span><span class=n>xrw</span><span class=p>)</span>      <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x20000000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>256</span><span class=n>K</span>
</span></span><span class=line><span class=cl>  <span class=n>SDRAM</span> <span class=p>(</span><span class=n>xrw</span><span class=p>)</span>     <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x90000000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>8</span><span class=n>M</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Each memory region can have a list of attributes that specify the permissions for each memory region. Possible attributes are:</p><ul><li><code>r</code>: read attribute</li><li><code>w</code>: write attribute</li><li><code>x</code>: execute attribute</li><li><code>a</code>: allocate attribute</li><li><code>l</code>: load attribute</li></ul><p>These attributes will be matched against the attributes of each section. For instance, .rodata and .text would be placed in Flash because they are not writable. However, things are a bit more complex when two regions have the same attributes. In order to place the output in a specific region we could indicate it using the following syntax:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=p>.</span><span class=nl>isr_vector</span> <span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>exceptions</span><span class=p>.</span><span class=n>o</span> <span class=p>(.</span><span class=n>isr_vector</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=o>&gt;</span> <span class=n>FLASH</span>
</span></span></code></pre></td></tr></table></div></div><p>This will place the isr vector section in the FLASH region. Both LMA amd VMA will be the same. How about loading the section to FLASH but setting the virtual memory address to SRAM? We could use this syntax:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=p>.</span><span class=n>data</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=o>&gt;</span> <span class=n>RAM</span> <span class=n>AT</span><span class=o>&gt;</span> <span class=n>FLASH</span>
</span></span></code></pre></td></tr></table></div></div><p>An advantage of using regions is that, since they have maximum sizes, the linker can issue an error when a region is not large enough to fit all the data. If this happens we may get an error message like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>section</span> <span class=err>`</span><span class=p>.</span><span class=n>text</span><span class=err>&#39;</span> <span class=n>will</span> <span class=n>not</span> <span class=n>fit</span> <span class=n>in</span> <span class=n>region</span> <span class=err>`</span><span class=n>FLASH</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl><span class=n>region</span> <span class=err>`</span><span class=n>FLASH</span><span class=err>&#39;</span> <span class=n>overflowed</span> <span class=n>by</span> <span class=mi>125</span> <span class=n>bytes</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=specifying-symbols-in-the-linker-script>Specifying symbols in the linker script</h2><p>It is possible to create new symbols in the linker script and lint to them in our code. This is particularly useful for the startup code, where we need to provide the LMA and VMA of the .data section, as well as the size. Thankfully we can perform symbol assignments directly in the linker script. Let&rsquo;s see an example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=p>.</span><span class=nl>data</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_data_start</span> <span class=o>=</span> <span class=p>.;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>_data_end</span> <span class=o>=</span> <span class=p>.;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=o>&gt;</span><span class=n>RAM</span> <span class=n>AT</span><span class=o>&gt;</span><span class=n>FLASH</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>_data_size</span> <span class=o>=</span> <span class=n>_data_end</span> <span class=o>-</span> <span class=n>_data_start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Obtain the load address (LMA) of the data section */</span>
</span></span><span class=line><span class=cl>  <span class=n>_data_loadaddr</span> <span class=o>=</span> <span class=n>LOADADDR</span><span class=p>(.</span><span class=n>data</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>The <code>_data_start</code> symbol is placed at the beginning of the output data section (this is, the VMA address of .data). Similarly, the <code>_data_end</code> symbol is placed at the end of the data section symbol. We can perform some arithmetic in order to calculate the size of the data section and store it in <code>_data_size</code>. Finally, the <code>LOADADDR</code> function can be used to obtain the LMA of <code>.data</code>.</p><p>Now we can access these symbols from our startup code in a similar fashion to what we did in our previous article about <a href=/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/>startup code</a>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>extern</span> <span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span> <span class=n>_data_start</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span> <span class=n>_data_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span> <span class=n>_data_loadaddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>copy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>_data_loadaddr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>_data_loadaddr</span> <span class=o>+</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=o>&amp;</span><span class=n>_data_size</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>_data_start</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>Notice that we declare these variables as external. The linker will provide proper addresses for them. Symbols defined by the linker do not have any allocated memory, but rather reside at a specific memory address. Since we care about the address of these symbols, the proper way to access them is to dereference the variable. Yes, this is the proper syntax.</p><h2 id=some-final-thoughts>Some final thoughts</h2><p>I hope this article gave you enough confidence to face the linker and maybe even write your own linker script next time you start a project. Even though most of the time we can get away with just using the default linker script, this is particularly useful when we have multiple types of memory (maybe some are tightly coupled to the core and others are larger and maybe are cached). Having the ability to control the exact placement of code and data for your program will allow optimizations to take place and avoid accessing the data only via pointers to the specific memory addresses.</p><p>We could even access the hardware in a completely memory mapped fashion with the linker. Think about having the following definition:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/* define structure of Port Pin*/</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>Bit0</span><span class=p>:</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>Bit1</span><span class=p>:</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>Bit2</span><span class=p>:</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>Bit3</span><span class=p>:</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>Bit31</span><span class=p>:</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>S_GPIO_REG</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>S_GPIO_REG</span> <span class=n>gpio_reg</span> <span class=nf>__attribute__</span><span class=p>((</span><span class=n>section</span><span class=p>(</span><span class=s>&#34;.bss.gpio_reg&#34;</span><span class=p>)));</span>
</span></span></code></pre></td></tr></table></div></div><p>This would declare a 32 bit register and we would be able to map it at the specific address where the hardware register is located (let&rsquo;s say address 0x40002000) with the following linker definition:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=p>.</span><span class=n>gpio_reg</span> <span class=mh>0x40002000</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=p>(.</span><span class=n>bss</span><span class=p>.</span><span class=n>gpio_reg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Javier Alvarez</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2020-04-11</span></p></div><footer class=post-footer><div class=post-tags><a href=/staging-web/tags/arm/>ARM</a>
<a href=/staging-web/tags/binutils/>Binutils</a>
<a href=/staging-web/tags/cortex-m/>Cortex-M</a>
<a href=/staging-web/tags/gnu/>GNU</a>
<a href=/staging-web/tags/linker-script/>Linker Script</a>
<a href=/staging-web/tags/microcontroller/>Microcontroller</a></div><nav class=post-nav><a class=prev href=/staging-web/post/bare-metal-register-access-api/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Bare Metal C++ Register Access API</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/staging-web/post/2019-10-12-bootloaders-and-arm-cortex-m-microcontrollers-booting-the-target-application/><span class="next-text nav-default">Bootloaders and ARM Cortex-M microcontrollers: Booting the target application</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=allthingsembedded/allthingsembedded.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:javier.alvarez@allthingsembedded.net class="iconfont icon-email" title=email></a><a href=https://twitter.com/Javier_varez class="iconfont icon-twitter" title=twitter></a><a href="https://www.linkedin.com/in/javieralvarez17/?locale=en_US" class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/Javier-varez class="iconfont icon-github" title=github></a><a href type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span><span class=copyright-year>&copy;
2018 -
2024<span class=heart><i class="iconfont icon-heart"></i></span><span></span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/staging-web/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script><script type=text/javascript>window.MathJax={tex:{}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>