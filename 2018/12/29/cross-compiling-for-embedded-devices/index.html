<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Cross-compiling for embedded devices - AllThingsEmbedded</title>
<meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Javier Alvarez"><meta name=description content="Developing code for embedded devices is somewhat different from code for mainstream computers. One of these differences is the development environment.
Most of the target microcontrollers or microprocessors won&amp;rsquo;t usually be suited for local development. Imagine trying to build your code on the target when the target is a simple 8-bit Microcontroller. First of all you would need a compiler for the target architecture on the target device and it would probably be extra slow and inconvenient."><meta name=keywords content="Software,Embedded,Engineering"><meta name=generator content="Hugo 0.131.0 with theme even"><link rel=canonical href=https://allthingsembedded.com/staging-web/2018/12/29/cross-compiling-for-embedded-devices/><link rel=apple-touch-icon sizes=180x180 href=/staging-web/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/staging-web/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/staging-web/favicon-16x16.png><link rel=manifest href=/staging-web/manifest.json><link rel=mask-icon href=/staging-web/safari-pinned-tab.svg color=#5bbad5><link href=/staging-web/sass/main.min.64709dea827fd8cd68163871eecb608b9747dba02f31ef7b78b54b5be491b06c.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:url" content="https://allthingsembedded.com/staging-web/2018/12/29/cross-compiling-for-embedded-devices/"><meta property="og:site_name" content="AllThingsEmbedded"><meta property="og:title" content="Cross-compiling for embedded devices"><meta property="og:description" content="Developing code for embedded devices is somewhat different from code for mainstream computers. One of these differences is the development environment.
Most of the target microcontrollers or microprocessors won’t usually be suited for local development. Imagine trying to build your code on the target when the target is a simple 8-bit Microcontroller. First of all you would need a compiler for the target architecture on the target device and it would probably be extra slow and inconvenient."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-12-29T17:36:13+00:00"><meta property="article:modified_time" content="2018-12-29T17:36:13+00:00"><meta property="article:tag" content="Buildroot"><meta property="article:tag" content="Cross-Compilation"><meta property="article:tag" content="Crosstool-NG"><meta property="article:tag" content="Embedded"><meta property="article:tag" content="GCC"><meta property="article:tag" content="Linux"><meta itemprop=name content="Cross-compiling for embedded devices"><meta itemprop=description content="Developing code for embedded devices is somewhat different from code for mainstream computers. One of these differences is the development environment.
Most of the target microcontrollers or microprocessors won’t usually be suited for local development. Imagine trying to build your code on the target when the target is a simple 8-bit Microcontroller. First of all you would need a compiler for the target architecture on the target device and it would probably be extra slow and inconvenient."><meta itemprop=datePublished content="2018-12-29T17:36:13+00:00"><meta itemprop=dateModified content="2018-12-29T17:36:13+00:00"><meta itemprop=wordCount content="1088"><meta itemprop=keywords content="Buildroot,Cross-Compilation,Crosstool-NG,Embedded,GCC,Linux,QEMU,Toolchain"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cross-compiling for embedded devices"><meta name=twitter:description content="Developing code for embedded devices is somewhat different from code for mainstream computers. One of these differences is the development environment.
Most of the target microcontrollers or microprocessors won’t usually be suited for local development. Imagine trying to build your code on the target when the target is a simple 8-bit Microcontroller. First of all you would need a compiler for the target architecture on the target device and it would probably be extra slow and inconvenient."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo id=mobile-header-logo></a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/staging-web/><li class=mobile-menu-item>Home</li></a><a href=/staging-web/post/><li class=mobile-menu-item>Archives</li></a><a href=/staging-web/tags/><li class=mobile-menu-item>Tags</li></a></ul></nav><script type=text/javascript src=/js/common.js></script><script type=text/javascript>colorize_base16("mobile-header-logo","AllThingsEmbedded")</script><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo id=logo-wrapper></a></div><script type=text/javascript src=/js/common.js></script><script type=text/javascript>colorize_base16("logo-wrapper","AllThingsEmbedded")</script><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/staging-web/>Home</a></li><li class=menu-item><a class=menu-item-link href=/staging-web/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/staging-web/tags/>Tags</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Cross-compiling for embedded devices</h1><div class=post-meta><span class=post-time>2018-12-29 </span><span class=more-meta>1088 words </span><span class=more-meta>6 mins read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#how-do-cross-compilers-work>How do cross-compilers work?</a></li><li><a href=#building-a-cross-compiler-toolchain>Building a cross-compiler toolchain</a></li></ul></li></ul></nav></div></div><div class=post-content><p>Developing code for embedded devices is somewhat different from code for mainstream computers. One of these differences is the development environment.</p><p>Most of the target microcontrollers or microprocessors won&rsquo;t usually be suited for local development. Imagine trying to build your code on the target when the target is a simple 8-bit Microcontroller. First of all you would need a compiler for the target architecture on the target device and it would probably be extra slow and inconvenient. That is the reason behind cross-compilers (provided that the uC has enough power and memory to perform the compilation process).</p><p>Cross-compilers are run on mainstream computers, whilst they generate code for the target Microcontroller (which will most likely have a different architecture). This is crucial when we are developing code for target processors that don&rsquo;t support a mainstream operating system such as GNU/Linux.</p><p>Having a cross-compiler is useful even when the target device supports GNU/Linux. Think of the Raspberry Pi. It could be, after all, a small personal computer. You could compile code on the device. However, there are still reasons for using cross-compilers with embedded Linux devices, being the most common speed and convenience.</p><p>Many times we work on embedded devices for which we don&rsquo;t have yet the target hardware available. In order to keep the schedule and being able to meet tight deadlines we are better off starting a dual-target project until the target hardware is available. Establishing a build environment on a mainstream computer is then paramount. You could even start testing some of the hardware dependent features on emulators such as QEMU, while most of the application code could be testable and subject to Test Driven Development (We will talk about this in the future, since it is not only applicable to embedded devices, but an integral part of developing good quality code for any type of device) on the local and target architectures.</p><h2 id=how-do-cross-compilers-work>How do cross-compilers work?</h2><p>Well, they work just like any other compiler. The main difference is that the generated binaries and elf files cannot be run on the local architecture. For an example about a compiler we will examine the GCC toolchain:</p><p>GCC is an acronym for GNU Compiler Collection. It is not just a compiler, but also some other assorted tools that let you manipulate executable files and generate binaries in multiple formats. The C compiler in GCC is also called gcc (GNU C Compiler), whilst the C++ compiler is a binary named g++.</p><p>The job of the compiler is to take source code and transform it into some object code that is able to run on the target platform. This is done in a few separate steps:</p><ul><li>Preprocessing:<ul><li>The first step is running the C Preprocessor on each of the source files. This will replace all preprocessor directives such as #define and #include, creating a final file that can be parsed by the compiler itself. It substitutes all define directives and includes all header files in the source file, as well as handling some compile time conditional statements such as #ifdef.</li><li>GCC can run this phase using the cpp command.</li></ul></li><li>Compilation:<ul><li>This stage takes care of translating all the source code to the assembly language required for the target processor. The compiler usually translates the source code first into an intermediate representation that can be interpreted by the optimizer and with which it can decide to make optimizations on the code to reduce the size of it and increase performance. Later, this intermediate representation is translated into the ASM language used for the target language. Function names and variable names are translated into symbols that are exported whenever it is necessary. Unresolved symbols will be taken care of later in the build process.</li><li>GCC can run this phase using the gcc -S or g++ -S commands</li></ul></li><li>Assembly:<ul><li>Once the code for each source file has been transformed into ASM files, the assembler can run and convert each of the instructions into machine code or object code that can be run directly on the target. In addition to the machine code, the object file also includes information about the symbols required and contained within the code.</li><li>GCC uses the as command to assemble the ASM sources.</li></ul></li><li>Linkage:<ul><li>The last step in this process is the running the <strong>linker</strong>. This step takes care of resolving missing symbols and can perform optimizations such as removing unused code and data. It basically merges all object files into a single executable. The linker can also link other code contained in libraries (static or shared).</li></ul></li></ul><p>The build process can be summarized in the following image:</p><p><img src=/images/Compiler_tools-2.png alt="Compiler tools"></p><h2 id=building-a-cross-compiler-toolchain>Building a cross-compiler toolchain</h2><p>Now, let&rsquo;s say that we need to work on a new device with the ARMv7m architecture and it will run on bare metal or some RTOS that is compiled with the application itself. We will need a cross-compiler toolchain to work on this device. Since ARMv7m is a pretty common architecture nowadays in the microcontroller world and it is very well supported, we can find a prebuilt GCC toolchain for all major OS&rsquo;s <a href=https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads>here</a>.</p><p>However this might not be the case for all embedded devices. It is a very painful process to build the whole toolchain from the sources. Not only that, but you will also need some support libraries (given that the target architecture is not the same as your development environment we can&rsquo;t use the same libraries). These include libc, libc++, libm, etc. In the case of the prebuilt toolchain in the above paragraph, the library included in the toolchain is newlib-nano, a lightweight version of the C standard library aimed for better performance on small embedded devices that don&rsquo;t require the support level of mainstream GNU/Linux environments.</p><p>Luckily there is an open source tool with which the toolchain creation process is greatly simplified. <a href=http://crosstool-ng.github.io>croostool-NG</a> is an open source toolchain generator that can be configured using common tools such as menuconfig. I won&rsquo;t be describing the whole installation and build process for a new toolchain, however, I will comment on the benefits of using this tool to build your cross-compiler toolchain.</p><p>There are similar projects that allow you to get build your own toolchain such as buildroot. However, <a href=https://buildroot.org>buildroot</a> is not only a toolchain generator, but it can also generate root file systems for Embedded Linux Devices with custom needs. It can even build the kernel and the bootloader. However, I still feel that crosstool-NG is a better solution for those projects where you will not use Embedded Linux, since buildroot is overkill and less specialized.</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Javier Alvarez</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2018-12-29</span></p></div><footer class=post-footer><div class=post-tags><a href=/staging-web/tags/buildroot/>buildroot</a>
<a href=/staging-web/tags/cross-compilation/>Cross-compilation</a>
<a href=/staging-web/tags/crosstool-ng/>crosstool-NG</a>
<a href=/staging-web/tags/embedded/>Embedded</a>
<a href=/staging-web/tags/gcc/>GCC</a>
<a href=/staging-web/tags/linux/>Linux</a>
<a href=/staging-web/tags/qemu/>QEMU</a>
<a href=/staging-web/tags/toolchain/>toolchain</a></div><nav class=post-nav><a class=prev href=/staging-web/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">ARM Cortex-M Startup code (for C and C++)</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/staging-web/2018/12/29/adding-gpt-support-to-fatfs/><span class="next-text nav-default">Adding GPT support to FatFS</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=allthingsembedded/allthingsembedded.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:javier.alvarez@allthingsembedded.net class="iconfont icon-email" title=email></a><a href=https://twitter.com/Javier_varez class="iconfont icon-twitter" title=twitter></a><a href="https://www.linkedin.com/in/javieralvarez17/?locale=en_US" class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/Javier-varez class="iconfont icon-github" title=github></a><a href type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span><span class=copyright-year>&copy;
2018 -
2024<span class=heart><i class="iconfont icon-heart"></i></span><span></span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/staging-web/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script><script type=text/javascript>window.MathJax={tex:{}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>