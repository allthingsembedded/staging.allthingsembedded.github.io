<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Adding GPT support to FatFS - AllThingsEmbedded</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="Javier Alvarez"><meta name=description content="FatFs is an open source library used in many embedded devices to interface with FAT file systems in Block devices such as SD cards, flash drives, etc. It can load a FAT or ExFAT filesystem found inside a partition in an MBR partition table. However, it doesn&amp;rsquo;t provide support to find a FAT filesystem inside a GUID partition table.
This blog post will provide you with the knowledge required to load a FAT filesystem inside a GUID partition table using FatFS."><meta name=keywords content="Software,Embedded,Engineering">
<meta name=generator content="Hugo 0.88.1 with theme even">
<link rel=canonical href=https://allthingsembedded.com/2018/12/29/adding-gpt-support-to-fatfs/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<link href=/sass/main.min.64709dea827fd8cd68163871eecb608b9747dba02f31ef7b78b54b5be491b06c.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<meta property="og:title" content="Adding GPT support to FatFS">
<meta property="og:description" content="FatFs is an open source library used in many embedded devices to interface with FAT file systems in Block devices such as SD cards, flash drives, etc. It can load a FAT or ExFAT filesystem found inside a partition in an MBR partition table. However, it doesn&rsquo;t provide support to find a FAT filesystem inside a GUID partition table.
This blog post will provide you with the knowledge required to load a FAT filesystem inside a GUID partition table using FatFS.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://allthingsembedded.com/2018/12/29/adding-gpt-support-to-fatfs/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2018-12-29T11:27:30+00:00">
<meta property="article:modified_time" content="2018-12-29T11:27:30+00:00">
<meta itemprop=name content="Adding GPT support to FatFS">
<meta itemprop=description content="FatFs is an open source library used in many embedded devices to interface with FAT file systems in Block devices such as SD cards, flash drives, etc. It can load a FAT or ExFAT filesystem found inside a partition in an MBR partition table. However, it doesn&rsquo;t provide support to find a FAT filesystem inside a GUID partition table.
This blog post will provide you with the knowledge required to load a FAT filesystem inside a GUID partition table using FatFS."><meta itemprop=datePublished content="2018-12-29T11:27:30+00:00">
<meta itemprop=dateModified content="2018-12-29T11:27:30+00:00">
<meta itemprop=wordCount content="2006">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Adding GPT support to FatFS">
<meta name=twitter:description content="FatFs is an open source library used in many embedded devices to interface with FAT file systems in Block devices such as SD cards, flash drives, etc. It can load a FAT or ExFAT filesystem found inside a partition in an MBR partition table. However, it doesn&rsquo;t provide support to find a FAT filesystem inside a GUID partition table.
This blog post will provide you with the knowledge required to load a FAT filesystem inside a GUID partition table using FatFS."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo id=mobile-header-logo>
</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>Home</li>
</a><a href=/post/>
<li class=mobile-menu-item>Archives</li>
</a><a href=/tags/>
<li class=mobile-menu-item>Tags</li>
</a>
</ul>
</nav>
<script type=text/javascript src=/js/common.js></script>
<script type=text/javascript>colorize_base16("mobile-header-logo","AllThingsEmbedded")</script>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo id=logo-wrapper>
</a>
</div>
<script type=text/javascript src=/js/common.js></script>
<script type=text/javascript>colorize_base16("logo-wrapper","AllThingsEmbedded")</script>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>Home</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post/>Archives</a>
</li><li class=menu-item>
<a class=menu-item-link href=/tags/>Tags</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<header class=post-header>
<h1 class=post-title>Adding GPT support to FatFS</h1>
<div class=post-meta>
<span class=post-time> 2018-12-29 </span>
<span class=more-meta> 2006 words </span>
<span class=more-meta> 10 mins read </span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>Contents</h2>
<div class="post-toc-content always-active">
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#basic-understanding-of-the-guid-partition-table>Basic understanding of the GUID partition table</a></li>
<li><a href=#adding-gpt-support-to-fatfs>Adding GPT support to FatFS</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<p><a href=http://elm-chan.org/fsw/ff/00index_e.html>FatFs</a> is an open source library used in many embedded devices to interface with FAT file systems in Block devices such as SD cards, flash drives, etc. It can load a FAT or ExFAT filesystem found inside a partition in an MBR partition table. However, it doesn&rsquo;t provide support to find a FAT filesystem inside a GUID partition table.</p>
<p>This blog post will provide you with the knowledge required to load a FAT filesystem inside a GUID partition table using FatFS. For this purpose, I have chosen revision R0.10b, mainly because it is the currently supported version for Xilinx SDK Board Support Package for Zynq devices.</p>
<h2 id=basic-understanding-of-the-guid-partition-table>Basic understanding of the GUID partition table</h2>
<p>The GPT is a part of the UEFI standard and a successor of the old MBR. It overcomes many of the problems of the MBR, such as being able to store more than 4 partitions on a single disk and supporting much larger disks of up to 8 ZiB instead of 2 TiB maximum for the MBR. It also abandons the terms of cylinder, head, sector addressing of the MBR (inherited from physical disks) for a much simpler block addressing using logical block addresses.</p>
<p>At LBA 0 the GPT starts with a protective MBR. This is an MBR that contains only one partition (the GUID partition table) with type 0xEE which holds the whole disk. It is used as a protection mechanism to ensure that older systems don&rsquo;t just format the disk after finding a corrupt partition table.</p>
<p>After the protective MBR, LBA 1 contains the main GPT header, which is also found at the end of the disk (also known as the secondary GPT header). This header starts with the magic bytes <code>EFI PART</code>, which can be used to identify the header. It contains some useful stuff such as the backup LBA (location of the secondary header table), the single partition entry size (usually 128 bytes), the first LBA used for partition entries (Usually set to LBA 2), The first LBA that can be used for partitions (usually LBA 34), etc.</p>
<p>Now, since we can assume the LBA size to be 512 bytes, the partition entry size of 128 bytes and the total number of LBA&rsquo;s allocated for partitions is 34 - 2 = 32, we can calculate the maximum number of partition entries:</p>
<p>$$ 512 \frac{bytes}{LBA} \div 128 \frac{bytes}{partition} \times 32 LBA = 128 \frac{partitions}{GPT} $$</p>
<p>Lastly, we are going to talk about the structure of a partition table entry. A partition table entry contains the name of the partition, the GUID type (use to determine the type of the partition), the address of the first LBA and the last LBA and a series of attributes. These attributes might be used for specific purposes for a given GUID type. For example, Android uses these attributes to store A/B partition boot information that can be later retrieved by the bootctrl HAL during runtime (check this <a href=https://android.googlesource.com/platform/hardware/qcom/bootctrl/+/master/boot_control.cpp>link</a> to find out more).</p>
<p>More information on this subject can be found <a href=https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries_(LBA_2%E2%80%9333)>here</a>.</p>
<h2 id=adding-gpt-support-to-fatfs>Adding GPT support to FatFS</h2>
<p>Mounting a disk in FatFS means identifying the content of the disk (MBR and each partition) and then finding the correct volume to mount within the disk. This is done by the function <code>find_volume</code> in ff.c.</p>
<p>This function checks if there is a Master Boot Record on the disk and then iterates through each partition to find one with a valid FAT filesystem.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=cm>/* Find a FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */</span>
<span class=n>bsect</span> <span class=o>=</span> <span class=mi>0U</span><span class=p>;</span>
<span class=cm>/* Load sector 0 and check if it is an FAT boot sector as SFD */</span>
<span class=n>fmt</span> <span class=o>=</span> <span class=n>check_fs</span><span class=p>(</span><span class=n>fs</span><span class=p>,</span> <span class=n>bsect</span><span class=p>);</span>
<span class=cm>/* Not an FAT boot sector or forced partition number */</span>
<span class=k>if</span> <span class=p>((</span><span class=n>fmt</span> <span class=o>==</span> <span class=mi>1U</span><span class=p>)</span> <span class=o>||</span> <span class=p>(((</span><span class=o>!</span><span class=n>fmt</span><span class=p>)</span> <span class=o>!=</span> <span class=p>(</span><span class=n>BYTE</span><span class=p>)</span><span class=mi>0U</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>((</span><span class=n>LD2PT</span><span class=p>(</span><span class=n>vol</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0U</span><span class=p>)))</span> <span class=p>{</span>
    <span class=n>UINT</span> <span class=n>i</span><span class=p>;</span>
    <span class=n>DWORD</span> <span class=n>br</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
    <span class=cm>/* Get partition offset */</span>
     <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0U</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>4U</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>BYTE</span> <span class=o>*</span><span class=n>pt</span> <span class=o>=</span> <span class=n>fs</span><span class=o>-&gt;</span><span class=n>win</span><span class=o>+</span><span class=n>MBR_Table</span> <span class=o>+</span> <span class=p>((</span><span class=n>WORD</span><span class=p>)</span><span class=n>i</span> <span class=o>*</span> <span class=p>(</span><span class=n>WORD</span><span class=p>)</span><span class=n>SZ_PTE</span><span class=p>);</span>
        <span class=n>br</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>((</span><span class=o>*</span><span class=p>(</span><span class=n>pt</span><span class=o>+</span><span class=mi>4</span><span class=p>))</span> <span class=o>!=</span> <span class=p>(</span><span class=n>BYTE</span><span class=p>)</span><span class=mi>0U</span><span class=p>)</span> <span class=o>?</span> <span class=n>LD_DWORD</span><span class=p>((</span><span class=n>pt</span><span class=o>+</span><span class=mi>8U</span><span class=p>))</span> <span class=o>:</span> <span class=mi>0U</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=cm>/* Partition number: 0:auto, 1-4:forced */</span>
    <span class=n>i</span> <span class=o>=</span> <span class=n>LD2PT</span><span class=p>(</span><span class=n>vol</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=mi>0U</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>i</span><span class=o>--</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>do</span> <span class=p>{</span>
        <span class=cm>/* Find an FAT volume */</span>
        <span class=n>bsect</span> <span class=o>=</span> <span class=n>br</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=cm>/* Check the partition */</span>
        <span class=n>fmt</span> <span class=o>=</span> <span class=p>(</span><span class=n>bsect</span><span class=o>!=</span><span class=p>(</span><span class=n>DWORD</span><span class=p>)</span><span class=mi>0U</span><span class=p>)</span> <span class=o>?</span> <span class=n>check_fs</span><span class=p>(</span><span class=n>fs</span><span class=p>,</span> <span class=n>bsect</span><span class=p>)</span> <span class=o>:</span> <span class=mi>2U</span><span class=p>;</span>
        <span class=n>i</span> <span class=o>+=</span> <span class=p>(</span><span class=n>UINT</span><span class=p>)</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>while</span> <span class=p>((</span><span class=o>!</span><span class=n>LD2PT</span><span class=p>(</span><span class=n>vol</span><span class=p>))</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>fmt</span> <span class=o>!=</span> <span class=p>(</span><span class=n>BYTE</span><span class=p>)</span><span class=mi>0U</span><span class=p>)</span><span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=mi>4U</span><span class=p>));</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>check_fs</code> function is in charge of finding a FAT partition inside an MBR partition table or at the start of the block determined by bsect. It returns 0 if it found an MBR partition table in the selected sector. Returns 1 if it found a valid partition but it is not FAT and it returns 2 if it doesn&rsquo;t find a valid boot sector. For our purposes, we expect here to get a 1 return value, since it will find a valid partition of type 0xEE that matches with the protective MBR first partition.</p>
<p>If this is the case it will try to iterate over all four available partitions (assuming that the user is not forcing any particular partition via the LD2PT macro). It will run the <code>check_fs</code> function for each partition entry offset until it finds one that is actually a FAT boot sector. When it finds it, it stores the bsect value for the corresponding FAT volume and continues loading the volume at the appropriate sector address.</p>
<p>We need to modify this section of the code to identify a Protective MBR in the case that the first <code>check_fs</code> calls returns 1 (Found valid partition but not FAT). We will do this using a <code>checkProtectiveMbr</code> function.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span>
<span class=n>DWORD</span> <span class=nf>checkProtectiveMbr</span><span class=p>(</span><span class=n>FATFS</span> <span class=o>*</span><span class=n>fs</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>UINT</span> <span class=n>i</span><span class=p>;</span>
    <span class=cm>/* Get partition offset */</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0U</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>4U</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>BYTE</span> <span class=o>*</span><span class=n>pt</span> <span class=o>=</span> <span class=n>fs</span><span class=o>-&gt;</span><span class=n>win</span><span class=o>+</span><span class=n>MBR_Table</span> <span class=o>+</span> <span class=p>((</span><span class=n>WORD</span><span class=p>)</span><span class=n>i</span> <span class=o>*</span> <span class=p>(</span><span class=n>WORD</span><span class=p>)</span><span class=n>SZ_PTE</span><span class=p>);</span>
        <span class=n>BYTE</span> <span class=n>partition_type</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>pt</span><span class=o>+</span><span class=mi>4</span><span class=p>);</span>
        <span class=n>xil_printf</span><span class=p>(</span><span class=s>&#34;Partition %d, type %02x</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>partition_type</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>partition_type</span> <span class=o>!=</span> <span class=mh>0xEE</span><span class=p>)</span> <span class=k>return</span> <span class=mh>0x00000000</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>partition_type</span> <span class=o>!=</span> <span class=mh>0x00</span><span class=p>)</span> <span class=k>return</span> <span class=mh>0x00000000</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>xil_printf</span><span class=p>(</span><span class=s>&#34;Found protective MBR</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=n>DWORD</span> <span class=n>LBA_EFI_PART</span> <span class=o>=</span> <span class=n>LD_DWORD</span><span class=p>((</span><span class=n>fs</span><span class=o>-&gt;</span><span class=n>win</span><span class=o>+</span><span class=n>MBR_Table</span><span class=o>+</span><span class=mi>8U</span><span class=p>));</span>
    <span class=n>xil_printf</span><span class=p>(</span><span class=s>&#34;EFI Partition at LBA %04x</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>LBA_EFI_PART</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>LBA_EFI_PART</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>This function returns the address for the first LBA of the EFI Partition table or a nullptr if it didn&rsquo;t find one. If we find the protective MBR we should proceed loading the EFI partition table and checking if any partition inside it satisfies the requirements of a FAT volume. We will do this using the <code>loadGPT</code> function that takes the LBA obtained in the checkProtectiveMbr function.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span>
<span class=n>DWORD</span> <span class=nf>loadGPT</span><span class=p>(</span><span class=n>FATFS</span> <span class=o>*</span><span class=n>fs</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>LBA</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Load EFI Part LBA into memory
</span><span class=c1></span>    <span class=n>move_window</span><span class=p>(</span><span class=n>fs</span><span class=p>,</span> <span class=n>LBA</span><span class=p>);</span>

    <span class=n>BYTE</span> <span class=n>is_efi_part</span> <span class=o>=</span> <span class=n>strncmp</span><span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>fs</span><span class=o>-&gt;</span><span class=n>win</span><span class=p>[</span><span class=n>EFI_MAGIC_OFFSET</span><span class=p>],</span>
            <span class=n>EFI_MAGIC</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=n>EFI_MAGIC</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>is_efi_part</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>xil_printf</span><span class=p>(</span><span class=s>&#34;EFI magic not found</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>);</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>xil_printf</span><span class=p>(</span><span class=s>&#34;EFI magic found</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>);</span>

    <span class=c1>// get size of partition entry
</span><span class=c1></span>    <span class=n>DWORD</span> <span class=n>partition_entry_size</span> <span class=o>=</span> <span class=n>fs</span><span class=o>-&gt;</span><span class=n>win</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_SIZE</span><span class=p>];</span>
    <span class=n>DWORD</span> <span class=n>partitions_per_lba</span> <span class=o>=</span> <span class=n>GPT_LBA_SIZE</span> <span class=o>/</span> <span class=n>partition_entry_size</span><span class=p>;</span>

    <span class=n>xil_printf</span><span class=p>(</span><span class=s>&#34;partition_entry_size %d</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>partition_entry_size</span><span class=p>);</span>
    <span class=n>xil_printf</span><span class=p>(</span><span class=s>&#34;partitions_per_lba %d</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>partitions_per_lba</span><span class=p>);</span>

    <span class=k>for</span> <span class=p>(</span><span class=n>BYTE</span> <span class=n>part_lba</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>part_lba</span> <span class=o>&lt;</span> <span class=mi>34</span><span class=p>;</span> <span class=n>part_lba</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// Load LBA into memory
</span><span class=c1></span>        <span class=n>move_window</span><span class=p>(</span><span class=n>fs</span><span class=p>,</span> <span class=n>part_lba</span><span class=p>);</span>

        <span class=k>for</span> <span class=p>(</span><span class=n>BYTE</span> <span class=n>part_entry_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
            <span class=n>part_entry_index</span> <span class=o>&lt;</span> <span class=n>partitions_per_lba</span><span class=p>;</span>
            <span class=n>part_entry_index</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>BYTE</span> <span class=o>*</span><span class=n>partition_entry</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>fs</span><span class=o>-&gt;</span><span class=n>win</span><span class=p>[</span><span class=n>part_entry_index</span> <span class=o>*</span> <span class=n>partition_entry_size</span><span class=p>];</span>
            <span class=n>xil_printf</span><span class=p>(</span><span class=s>&#34;partition %d type %02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>,</span>
                    <span class=p>(</span><span class=n>part_lba</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=n>partitions_per_lba</span> <span class=o>+</span> <span class=n>part_entry_index</span><span class=p>,</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>2</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>3</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>4</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>5</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>6</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>7</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>8</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>9</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>10</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>11</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>12</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>13</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>14</span><span class=p>],</span>
                    <span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=o>+</span><span class=mi>15</span><span class=p>]</span>
                    <span class=p>);</span>

            <span class=c1>// match expected guid type
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>memcmp</span><span class=p>(</span><span class=n>gpt_expected_fat_guid</span><span class=p>,</span>
                    <span class=o>&amp;</span><span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_TYPE_OFFSET</span><span class=p>],</span>
                    <span class=k>sizeof</span><span class=p>(</span><span class=n>gpt_expected_fat_guid</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
                <span class=c1>// found a matching partition. Check if it contains a valid FAT filesystem.
</span><span class=c1></span>                <span class=kt>uint32_t</span> <span class=n>matching_part_lba</span> <span class=o>=</span> <span class=o>*</span><span class=p>((</span><span class=kt>uint32_t</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>partition_entry</span><span class=p>[</span><span class=n>GPT_PART_ENTRY_FIRST_LBA_OFFSET</span><span class=p>]);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>check_fs</span><span class=p>(</span><span class=n>fs</span><span class=p>,</span> <span class=n>matching_part_lba</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// found matching FAT filesystem
</span><span class=c1></span>                    <span class=n>xil_printf</span><span class=p>(</span><span class=s>&#34;matching partition at LBA 0x%x</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>matching_part_lba</span><span class=p>);</span>
                    <span class=k>return</span> <span class=n>matching_part_lba</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>First of all, this functions checks the <code>EFI_MAGIC</code> bytes at the start of the main GUID partition table (which should match the string &ldquo;EFI PART&rdquo;). If it doesn&rsquo;t find the main GUID partition table inside the first partition of the protective MBR it simply returns with a nullptr to indicate that it didn&rsquo;t find a viable boot sector.</p>
<p>However, if we match the <code>EFI_MAGIC</code> bytes, we can continue to check all partition entries inside the newly found GUID partition table. For this, we will need to obtain the size for each partition entry (<code>partition_entry_size</code>) and the maximum number of partitions available per LBA (Assuming each LBA is 512 bytes). Since the <code>partition_entry_size</code> is usually 128, the number of partitions per LBA is usually 4.</p>
<p>Then, for all partition entries (ranging from LBA 2 to LBA 33) we search each partition and try to match the partition type found at offset <code>GPT_PART_ENTRY_TYPE_OFFSET</code>. Matching the partition type is not really required, but it is useful when you have multiple FAT partitions in the disk but you want to load one with a specific type UUID. For my use case  I generated the following UUID for the expected partition type:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=n>BYTE</span> <span class=n>gpt_expected_fat_guid</span><span class=p>[</span><span class=mi>16</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
        <span class=mh>0x66</span><span class=p>,</span> <span class=mh>0x9e</span><span class=p>,</span> <span class=mh>0x4c</span><span class=p>,</span> <span class=mh>0x36</span><span class=p>,</span>
        <span class=mh>0x3f</span><span class=p>,</span> <span class=mh>0xd1</span><span class=p>,</span> <span class=mh>0xdd</span><span class=p>,</span> <span class=mh>0x49</span><span class=p>,</span>
        <span class=mh>0x83</span><span class=p>,</span> <span class=mh>0x59</span><span class=p>,</span> <span class=mh>0x09</span><span class=p>,</span> <span class=mh>0x21</span><span class=p>,</span>
        <span class=mh>0xa3</span><span class=p>,</span> <span class=mh>0x53</span><span class=p>,</span> <span class=mh>0x9c</span><span class=p>,</span> <span class=mh>0x1c</span>
<span class=p>};</span>
</code></pre></td></tr></table>
</div>
</div><p>If it matches the type we check if it contains a valid FAT boot sector using the <code>check_fs</code> function and then return the first LBA of the FAT partition.</p>
<p>The only thing left to show is how to integrate both these functions inside the original <code>find_volume</code> function we first saw at the start of this section.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=cm>/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */</span>
    <span class=n>bsect</span> <span class=o>=</span> <span class=mi>0U</span><span class=p>;</span>
    <span class=cm>/* Load sector 0 and check if it is an FAT boot sector as SFD */</span>
    <span class=n>fmt</span> <span class=o>=</span> <span class=n>check_fs</span><span class=p>(</span><span class=n>fs</span><span class=p>,</span> <span class=n>bsect</span><span class=p>);</span>    
    <span class=cm>/* Not an FAT boot sector or forced partition number */</span>                
    <span class=k>if</span> <span class=p>((</span><span class=n>fmt</span> <span class=o>==</span> <span class=mi>1U</span><span class=p>)</span> <span class=o>||</span> <span class=p>(((</span><span class=o>!</span><span class=n>fmt</span><span class=p>)</span> <span class=o>!=</span> <span class=p>(</span><span class=n>BYTE</span><span class=p>)</span><span class=mi>0U</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>((</span><span class=n>LD2PT</span><span class=p>(</span><span class=n>vol</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0U</span><span class=p>)))</span> <span class=p>{</span>    
        <span class=n>UINT</span> <span class=n>i</span><span class=p>;</span>
        <span class=n>DWORD</span> <span class=n>br</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>

        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0U</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>4U</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=cm>/* Get partition offset */</span> 
            <span class=n>BYTE</span> <span class=o>*</span><span class=n>pt</span> <span class=o>=</span> <span class=n>fs</span><span class=o>-&gt;</span><span class=n>win</span><span class=o>+</span><span class=n>MBR_Table</span> <span class=o>+</span> <span class=p>((</span><span class=n>WORD</span><span class=p>)</span><span class=n>i</span> <span class=o>*</span> <span class=p>(</span><span class=n>WORD</span><span class=p>)</span><span class=n>SZ_PTE</span><span class=p>);</span>
            <span class=n>br</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>((</span><span class=o>*</span><span class=p>(</span><span class=n>pt</span><span class=o>+</span><span class=mi>4</span><span class=p>))</span> <span class=o>!=</span> <span class=p>(</span><span class=n>BYTE</span><span class=p>)</span><span class=mi>0U</span><span class=p>)</span> <span class=o>?</span> <span class=n>LD_DWORD</span><span class=p>((</span><span class=n>pt</span><span class=o>+</span><span class=mi>8U</span><span class=p>))</span> <span class=o>:</span> <span class=mi>0U</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>fmt</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=n>GPT_LBA</span> <span class=o>=</span> <span class=n>checkProtectiveMbr</span><span class=p>(</span><span class=n>fs</span><span class=p>);</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>GPT_LBA</span> <span class=o>!=</span> <span class=mh>0x00000000</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// Protective MBR identified. Search boot FAT partition.
</span><span class=c1></span>            <span class=n>bsect</span> <span class=o>=</span> <span class=n>loadGPT</span><span class=p>(</span><span class=n>fs</span><span class=p>,</span> <span class=n>GPT_LBA</span><span class=p>);</span>
            <span class=n>fmt</span> <span class=o>=</span> <span class=p>(</span><span class=n>bsect</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=mi>2</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=cm>/* Partition number: 0:auto, 1-4:forced */</span>
            <span class=n>i</span> <span class=o>=</span> <span class=n>LD2PT</span><span class=p>(</span><span class=n>vol</span><span class=p>);</span>    
            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=mi>0U</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>i</span><span class=o>--</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>do</span> <span class=p>{</span>    
                <span class=cm>/* Find an FAT volume */</span>                            
                <span class=n>bsect</span> <span class=o>=</span> <span class=n>br</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
                <span class=cm>/* Check the partition */</span>
                <span class=n>fmt</span> <span class=o>=</span> <span class=p>(</span><span class=n>bsect</span><span class=o>!=</span><span class=p>(</span><span class=n>DWORD</span><span class=p>)</span><span class=mi>0U</span><span class=p>)</span> <span class=o>?</span> <span class=n>check_fs</span><span class=p>(</span><span class=n>fs</span><span class=p>,</span> <span class=n>bsect</span><span class=p>)</span> <span class=o>:</span> <span class=mi>2U</span><span class=p>;</span>
                <span class=n>i</span> <span class=o>+=</span> <span class=p>(</span><span class=n>UINT</span><span class=p>)</span><span class=mi>1</span><span class=p>;</span>
            <span class=p>}</span> <span class=k>while</span> <span class=p>((</span><span class=o>!</span><span class=n>LD2PT</span><span class=p>(</span><span class=n>vol</span><span class=p>))</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>fmt</span> <span class=o>!=</span> <span class=p>(</span><span class=n>BYTE</span><span class=p>)</span><span class=mi>0U</span><span class=p>)</span><span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=mi>4U</span><span class=p>));</span>
        <span class=p>}</span>
    <span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>With this we have the final piece of the puzzle. Now the <code>find_volume</code> function will try to find a FAT volume inside the first partition. If it doesn&rsquo;t but finds an MBR it will check if it is a protective MBR. If it isn&rsquo;t it will check all 4 partitions in the MBR looking for a FAT partition. However, if it is a Protective MBR it will try to load the GPT table and match a FAT partition inside the GPT using both the partition format and the type GUID of the partition. If it does find these requirements then it loads the FAT partition inside the GPT, accomplishing our initial task of adding support for finding a FAT volume inside a GPT.</p>
<p>The complete code can be found on the following repository:</p>
<p><a href=https://bitbucket.org/javier_varez/zybobsp/commits/dc3600b21c472d82f27e8a4deeee701bb996a96a>Zynq BSP with support for GPT</a></p>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>Author</span>
<span class=item-content>Javier Alvarez</span>
</p>
<p class=copyright-item>
<span class=item-title>LastMod</span>
<span class=item-content>
2018-12-29
</span>
</p>
</div>
<footer class=post-footer>
<nav class=post-nav>
<a class=prev href=/2018/12/29/cross-compiling-for-embedded-devices/>
<i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Cross-compiling for embedded devices</span>
<span class="prev-text nav-mobile">Prev</span>
</a>
<a class=next href=/2018/09/02/displaying-text-on-embedded-devices/>
<span class="next-text nav-default">Displaying text on embedded devices</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i>
</a>
</nav>
</footer>
</article>
</div>
<script src=https://utteranc.es/client.js repo=allthingsembedded/allthingsembedded.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script>
<noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=mailto:javier.alvarez@allthingsembedded.net class="iconfont icon-email" title=email></a>
<a href=https://twitter.com/Javier_varez class="iconfont icon-twitter" title=twitter></a>
<a href="https://www.linkedin.com/in/javieralvarez17/?locale=en_US" class="iconfont icon-linkedin" title=linkedin></a>
<a href=https://github.com/Javier-varez class="iconfont icon-github" title=github></a>
<a href=https://allthingsembedded.com/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span>
<span class=copyright-year>
&copy;
2018 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>Javier Alvarez</span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
<script type=text/javascript>window.MathJax={tex:{}}</script>
<script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-120967880-1','auto'),ga('set','anonymizeIp',!0),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
</body>
</html>